"use strict";(self.webpackChunkdenntenna_github_io=self.webpackChunkdenntenna_github_io||[]).push([[5857],{36574:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return l},default:function(){return c}});var o=t(63366),r=(t(67294),t(64983)),i=t(66101),a=["components"],l={},s={_frontmatter:l},u=i.Z;function c(e){var n=e.components,t=(0,o.Z)(e,a);return(0,r.kt)(u,Object.assign({},s,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",null,"Shaders"),(0,r.kt)("h2",null,"Mental Model"),(0,r.kt)("p",null,"Shader is a function that takes position of a pixel (amongst other inputs) and returns the color of that pixel."),(0,r.kt)("p",null,"You have mathematical functions to emulate imperative programming. for instance, think of ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," function as a comparator that compares two inputs. Very much like an if condition. It returns a 0 or 1 (like the if condition). You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"smoothstep"),", if instead of a boolean you want a smooth transition between 0 and 1."),(0,r.kt)("h2",null,"glslviewer"),(0,r.kt)("p",null,"This is the best way to work on shaders because it provides you with almost a live coding environment for making shaders."),(0,r.kt)("p",null,"Lets say you are working on a fragment shader and need to work with a texture, run glslviewer with ",(0,r.kt)("inlineCode",{parentName:"p"},"../build/glslViewer shader.frag texture.png"),". This will open up a window where the shader can be previewed. Now, you can also open up shader.frag in a text editor. As you make changes to it, glsviewer live-reloads the new shader and you get instantaneous previews."),(0,r.kt)("h2",null,"Simple Shaders"),(0,r.kt)("h3",null,"Slide between two images with mouse"),(0,r.kt)("deckgo-highlight-code",{language:"glsl",terminal:"carbon"},"\n          ",(0,r.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"#version 100\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform sampler2D   u_tex0;\nuniform sampler2D   u_tex1;\n\nuniform vec2        u_mouse;\nuniform vec2        u_resolution;\nuniform float       u_time;\n\nvoid main (void) {\n    vec3 color = vec3(0.0);\n    vec3 color2 = vec3(0.0);\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mn = u_mouse/u_resolution;\n\n    color = texture2D(u_tex1, st).rgb;\n    color2 = texture2D(u_tex0, st).rgb;\n\n    float scale = step(mn.x, st.x);\n\n    gl_FragColor = vec4(color*scale+color2*(1.0-scale), 1.0);\n}"),"\n        "),(0,r.kt)("h3",null,"Circular Mask"),(0,r.kt)("deckgo-highlight-code",{language:"glsl",terminal:"carbon"},"\n          ",(0,r.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"#version 100\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform sampler2D   u_tex0;\nuniform sampler2D   u_tex1;\n\nuniform vec2        u_mouse;\nuniform vec2        u_resolution;\nuniform float       u_time;\n\nfloat circle(in vec2 _st, vec2 _mn, in float _radius){\n    vec2 dist = _st-_mn;\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid main (void) {\n    vec3 color = vec3(0.0);\n    vec3 color2 = vec3(0.0);\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mn = u_mouse/u_resolution;\n\n    color2 = texture2D(u_tex1, st).rgb;\n    color = texture2D(u_tex0, st).rgb;\n\n    vec3 scale = vec3(circle(st,mn, 0.05));\n\n    gl_FragColor = vec4(color*scale+color2*(1.0-scale), 1.0);\n\n}"),"\n        "))}c.isMDXComponent=!0},63366:function(e,n,t){function o(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}t.d(n,{Z:function(){return o}})}}]);
//# sourceMappingURL=component---src-pages-cheatsheets-shaders-mdx-26e7f5374fe1ddae54fd.js.map